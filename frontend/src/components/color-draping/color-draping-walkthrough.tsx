'use client';

import React, { useState, useEffect } from 'react';
import { ComprehensiveAnalysisResult } from '@/lib/analysis-service';
import { ColorDrapingData } from '@/lib/color-draping-types';
import { transformToColorDrapingData, validateColorDrapingData, createFallbackColorDrapingData } from '@/lib/color-draping-utils';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { X } from 'lucide-react';
import EntryScreen from './entry-screen';
import WalkthroughFlow from './walkthrough-flow';
import SummaryScreen from './summary-screen';

interface ColorDrapingWalkthroughProps {
  analysisResult: ComprehensiveAnalysisResult;
  userPhotoUrl: string;
  analysisId: string;
  onViewFullAnalysis: () => void;
  className?: string;
}

type WalkthroughState = 'entry' | 'walkthrough' | 'summary';

export const ColorDrapingWalkthrough: React.FC<ColorDrapingWalkthroughProps> = ({
  analysisResult,
  userPhotoUrl,
  analysisId,
  onViewFullAnalysis,
  className = ''
}) => {
  const [currentState, setCurrentState] = useState<WalkthroughState>('entry');
  const [drapingData, setDrapingData] = useState<ColorDrapingData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Initialize draping data
  useEffect(() => {
    const initializeDrapingData = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // First try to get pre-computed draping data from sessionStorage
        const storedDrapingData = sessionStorage.getItem(`draping_${analysisId}`);
        console.log('Stored draping data:', storedDrapingData ? 'Found' : 'Not found');

        if (storedDrapingData) {
          try {
            const parsedDrapingData = JSON.parse(storedDrapingData);
            console.log('Parsed draping data colors:', parsedDrapingData.colors?.slice(0, 3).map((c: any) => ({ name: c.name, hex: c.hex })));

            if (validateColorDrapingData(parsedDrapingData)) {
              setDrapingData(parsedDrapingData);
              return;
            } else {
              console.warn('Stored draping data failed validation');
            }
          } catch (parseError) {
            console.warn('Failed to parse stored draping data:', parseError);
          }
        }

        // Try to transform the analysis result directly
        if (analysisResult && userPhotoUrl) {
          console.log('Transforming analysis result to draping data');
          const transformedData = transformToColorDrapingData(analysisResult, userPhotoUrl, analysisId);

          if (validateColorDrapingData(transformedData)) {
            setDrapingData(transformedData);
            // Store for future use
            sessionStorage.setItem(`draping_${analysisId}`, JSON.stringify(transformedData));
            return;
          }
        }

        // If all else fails, create fallback data with user photo
        console.log('Using fallback data');
        const fallbackData = createFallbackColorDrapingData(analysisId);
        fallbackData.userPhoto = userPhotoUrl; // Ensure we have the user photo
        setDrapingData(fallbackData);

      } catch (err) {
        console.error('Failed to initialize draping data:', err);
        setError('Failed to prepare walkthrough data');

        // Use fallback data with user photo
        const fallbackData = createFallbackColorDrapingData(analysisId);
        fallbackData.userPhoto = userPhotoUrl;
        setDrapingData(fallbackData);
      } finally {
        setIsLoading(false);
      }
    };

    if (analysisResult && userPhotoUrl && analysisId) {
      initializeDrapingData();
    }
  }, [analysisResult, userPhotoUrl, analysisId]);

  const handleStartWalkthrough = () => {
    setCurrentState('walkthrough');
  };

  const handleWalkthroughComplete = () => {
    setCurrentState('summary');
  };

  const handleBackToEntry = () => {
    setCurrentState('entry');
  };

  const handleRestartWalkthrough = () => {
    setCurrentState('walkthrough');
  };

  const handleDownloadPalette = async () => {
    if (!drapingData) return;

    try {
      // Create a simple text format for download
      const paletteText = `
Your Color Analysis Results
===========================

Color Season: ${drapingData.colorSeason}

Best Colors:
${drapingData.colors
  .filter(c => c.verdict === 'best')
  .map(c => `• ${c.name} (${c.hex}) - ${c.feedback}`)
  .join('\n')}

Colors to Avoid:
${drapingData.colors
  .filter(c => c.verdict === 'avoid')
  .map(c => `• ${c.name} (${c.hex}) - ${c.feedback}`)
  .join('\n')}

Generated by Color Analysis Tool
      `.trim();

      const blob = new Blob([paletteText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `color-palette-${drapingData.colorSeason.toLowerCase().replace(' ', '-')}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Failed to download palette:', err);
      alert('Failed to download palette. Please try again.');
    }
  };

  const handleShareLookbook = async () => {
    if (!drapingData) return;

    try {
      if (navigator.share) {
        await navigator.share({
          title: `My Color Analysis - ${drapingData.colorSeason}`,
          text: `I just discovered I'm a ${drapingData.colorSeason}! Check out my personalized color palette.`,
          url: window.location.href
        });
      } else {
        // Fallback: copy to clipboard
        const shareText = `I just discovered I'm a ${drapingData.colorSeason}! Check out my personalized color palette: ${window.location.href}`;
        await navigator.clipboard.writeText(shareText);
        alert('Share text copied to clipboard!');
      }
    } catch (err) {
      console.error('Failed to share:', err);
      alert('Failed to share. Please try again.');
    }
  };

  if (isLoading) {
    return (
      <div className={`min-h-screen bg-background flex items-center justify-center p-4 ${className}`}>
        <Card className="max-w-md w-full shadow-lg">
          <CardContent className="p-8 text-center space-y-6">
            <div className="animate-spin w-12 h-12 border-4 border-primary/20 border-t-primary rounded-full mx-auto"></div>
            <div className="space-y-2">
              <h2 className="text-2xl font-bold text-foreground font-[Inter]">Preparing Your Color Walkthrough...</h2>
              <p className="text-muted-foreground font-[Inter]">
                Setting up your personalized draping experience
              </p>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (error || !drapingData) {
    return (
      <div className={`min-h-screen bg-background flex items-center justify-center p-4 ${className}`}>
        <Card className="max-w-md w-full shadow-lg">
          <CardContent className="p-8 text-center space-y-6">
            <div className="w-16 h-16 mx-auto bg-destructive/10 rounded-full flex items-center justify-center">
              <X className="w-8 h-8 text-destructive" />
            </div>
            <div className="space-y-2">
              <h2 className="text-2xl font-bold text-foreground font-[Inter]">Unable to Load Walkthrough</h2>
              <p className="text-muted-foreground font-[Inter]">
                {error || 'Something went wrong while preparing your color walkthrough.'}
              </p>
            </div>
            <Button
              onClick={onViewFullAnalysis}
              className="w-full bg-primary hover:bg-primary/90 text-primary-foreground font-[Inter]"
            >
              View Full Analysis Instead
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className={`color-draping-walkthrough ${className}`}>
      {currentState === 'entry' && (
        <EntryScreen
          onViewFullAnalysis={onViewFullAnalysis}
          onStartWalkthrough={handleStartWalkthrough}
          analysisComplete={true}
        />
      )}

      {currentState === 'walkthrough' && (
        <WalkthroughFlow
          drapingData={drapingData}
          onComplete={handleWalkthroughComplete}
          onBack={handleBackToEntry}
        />
      )}

      {currentState === 'summary' && (
        <SummaryScreen
          drapingData={drapingData}
          onDownloadPalette={handleDownloadPalette}
          onShareLookbook={handleShareLookbook}
          onRestartWalkthrough={handleRestartWalkthrough}
          onViewFullAnalysis={onViewFullAnalysis}
        />
      )}
    </div>
  );
};

export default ColorDrapingWalkthrough;